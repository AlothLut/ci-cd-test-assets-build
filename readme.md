# CI/CD build test

<details>
  <summary>Task</summary>
  
  # Задача

Реализовать сборку игровых ассетов (картинок, анимаций и т.д.) 

## Входные данные
Существует два типа ассетов - просто картинки и “бандлы”
  - Бандлы (Bundle) состоят из двух файлов - изображение `${name}.(png|jpg)` и текстовый файл `${name}.json` (`name` совпадает)
  - Соло-картинки - это просто одиночные файлы изображений `${name}.(png|jpg)`

Ассеты лежат в папке assets

## Процесс сборки

### Соло-картинки

- Пакуем в zip-архивы, по одной соло-картинке на архив. Имя архива = md5sum содержимого архива

### Бандлы

- Читаем `.json` конфиг
- В зависимости от значения поля `rotate` (может принимать значения `none`, `left`, `right`) поворачиваем картинку
- Конвертим картинку в `.png`
- Два файла - получившийся `.png` и `.json` - кладем в .zip архив аналогично соло-картинкам


# Задание

## Написать пайплайн паковки ассетов

- Как собираются ассеты - описано выше
- Сборка должна быть инкрементальной:
    - Собираться должны только изменившиеся (или добавленные) с последней сборки ассеты (Изменение любой части бандла равно изменению бандла)
- Артефактами сборки должны быть:
	- Собранные zip-архивы (только для изменившихся/добавленных ассетов)
	- Список неизменившихся ассетов 

# Общие требования к выполнению

- Пайплайн:
	- Можно реализовать на привычной вам платформе (Gitlab CI/CD | Teamcity | Github Actions | …)
	- После сдачи задания у нас должен быть доступ к пайплайну, чтобы подергать его и посмотреть на результат
- Репозиторий:
	- Содержимое репозитория = содержимое присланного вам .zip архива с заданием
	- Репозиторий можно создать на привычной вам платформе (Gitlab | Github | BitBucket | ...)
	- После сдачи задания у нас должен быть доступ к репозиторию, чтобы потестировать результат
- Вспомогательные скрипты:
	- Можно использовать python 3.6+, bash, kotlin

# Примеры 

Примеры можно найти в папке examples: 
* change - описание коммита
* result - директория с предполагаемым результатом сборки этого коммита (предполагается, что это не первая сборка)

</details>

## Dependencies:

##### docker, docker-compose

##### Tested on Ubuntu 20.1


## To run, execute sequentially:

Поднимаем локально gitlab + сетапим раннер

- docker-compose up -d
- Login: root
- Password получаем выполнив команду `docker-compose exec web cat /etc/gitlab/initial_root_password | grep Password:`


Для сетапа раннера получим токен:
http://localhost:8080/admin/runners  "Register and instace runner" -> copy token

Команда сетапа раннера:
`docker exec -it gitlab-runner gitlab-runner register --url "http://gitlab-ce" --clone-url "http://gitlab-ce"`

Нужно будет заполнять шаги.
Тег выставляем `docker-runner`, image например `alpine:latest`, остальные в произвольном варианте.

Добавим запись о хосте в конфиг раннера 
`docker-compose exec gitlab-runner sed -i '/runners.docker/a\    network_mode = "gitlab-network"' /etc/gitlab-runner/config.toml`

Проверим запуск раннера:
`http://localhost:8080/admin/runners`

TODO: проверить почему не работает ssh ключ
Пушить и пулить будем по http
Логин все также root, пароль: `docker-compose exec web cat /etc/gitlab/initial_root_password | grep Password:`

Создаем пустой проект.

В текущем репозитории добавляем remote нашего логального проекта на локальном gitlab
Пример `git remote add local http://localhost:8080/gitlab-instance-00616b93/test-ci.git`
Не забываем про кастомный порт 8080.

Пушим в master.

Переключаемся на dev ветку и создаем папку `assets` куда размещаем ассеты и пушим в дев.
Запустится Job билд которая посмотрит файлы отличные от master в папке assets и разместит полученные архивы в артефакт.

TODO: сбилдить образ со всеми зависимостями заранее а не в секции before_script